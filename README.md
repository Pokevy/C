1. 基本类型
|--整数类型
|    |--存储类型           符号            32位编译器      64位编译器
|    |    |--有符号整型    int                4               4
|    |    |--无符号整型    unsigned int       4               4
|    |    |--有符号短整型  short              2               2
|    |    |--无符号短整型  unsigned short     2               2
|    |    |--有符号长整型  long               4               8
|    |    |--无符号长整型  unsigned long      4               8
|    |
|    |--进制类型           前缀 |   二/八/十六进制 ==> 十进制：0378=3x8^2+7x8^1+8x8^0
|    |    |--二进制数      0b   |  （按权相加）
|    |    |--八进制数      0    |  
|    |    |--十进制数           |   十进制 ==> 二/八/十六进制：378/=8
|    |    |--十六进制数    0x   |  （除N取余，逆序排列）
|    |    |--注意：八进制和十六进制必须带前缀，长类型数据必须带后缀L
|    |
|    |--整形在内存存储
|    |    |--性质
|    |    |    |--在内存中，正数以源码形式存储，负数以补码形式存储
|    |    |    |--C语言规定，把内存的最高位作为符号位，在符号位中，用0代表整数，1代表负数
|    |    |    |--标准C语言不支持二进制写法，某些编译器自行扩展才支持
|    |    |--3个码
|    |    |    |--原码：将一个整数转换成二进制形式
|    |    |    |--反码：正数反码等于其本身，负数反码将除符号位以外的所有位取反
|    |    |    |--补码：正数补码等于其本身，负数补码是其反码加1
|
|--浮点类型
|    |--存储类型           符号            32位编译器        64位编译器
|    |    |--单精度型      float              4                4
|    |    |--双精度型      double             8                8
|    |    |--长双精度型    long double        16
|    |
|    |--表达形式
|    |    |--进制形式：0.0
|    |    |    |--整数部分可以省略
|    |    |--指数形式（aen）：2.1e5 <=> 2.1x10^5
|    |    |    |--其中a和n都不可省略
|    |
|    |--特殊说明
|    |    |--十进制形式中小数点前后位的数都可以省略
|    |    |--指数形式中e后面的数必须为整数，e前面的数位实数
|
|--字符类型                
|    |--类型               符号            32位编译器        64位编译器
|    |    |--字符型        char               1                 1
|    |    |--有符号字符型   signed char        1                 1
|    |    |--无符号字符型   unsigned char      1                 1
|    |
|    |--扩展
|    |    |--单个字符使用''括起来，多个字符（字符串/字符数组）使用""括起来
|    |    |--空格也是字符
|    |    |--字符存入内存时，会根据ASCII表转换为对应的十进制数，打印时根据打印类型打印
|
|--布尔类型
|    |--True    1
|    |--False   0
|
2. 派生类型
|--数组类型
|    |--一维数组（整型）
|    |    |--本质
|    |    |    |--一维数组是一组数据的集合，它所包含的每一个数据叫数组元素，所包含的数据个数称为数组长度
|    |    |    |--一维数组中每个元素都有一个下标，首元素下标为0，以此类推
|    |    |    |--一维数组在内存中是连续的，数组一旦被顶以后，占用的内存空间是不可变得
|    |    |
|    |    |--定义：dataType array[lenght]
|    |    |
|    |    |--初始化
|    |    |    |--可以先定义数组再给数组赋值，也可以定义数组同时赋值
|    |    |    |--给部分元素赋值时，剩余元素会自动初始化为0(int)、'\0'(char)、0.0(float/double)
|    |    |    |--如果给全部元素赋值，可以不给出数组长度
|    |
|    |--二维数组（整型）
|    |    |--本质
|    |    |    |--二维数组是多组数据的集合，length1为第一维下标的长度，length2为第二维下标的长度
|    |    |    |--二维数组可抽象为多个一维数组，要确定二维数组某个元素，必须指明两个纬度的下标
|    |    |    |--二位数组在内存上是连续的
|    |    |
|    |    |--定义：dataType array[lenght1][length2]
|    |    |
|    |    |--初始化
|    |    |    |--分段赋值：int p[3][2] = {{1,2}, {3,4}, {5,6}}
|    |    |    |--连续赋值：int p[3][2] = {1, 2, 3, 4, 5, 6}
|    |    |    |--给部分元素未赋值的元素会自动初始化为零
|    |    |    |--如果给全部元素赋值，那么第一维长度可以不给出
|    |
|    |--字符数组（一维）
|    |    |--本质
|    |    |    |--字符数组时一系列字符的集合（字符串）
|    |    |    |--字符串是一系列连续的字符的组合，以'\0'结尾即字符串结束符
|    |    |
|    |    |--定义
|    |    |    |--使用数组定义字符串      char p[]=""
|    |    |    |--使用指针变量定义字符串  char *p=""
|    |    |
|    |    |--初始化
|    |    |    |--""（全部赋值）包围的字符串会在末尾添加'\0'
|    |    |    |--''（逐个赋值）包围的字符不会在字符数组末尾添加'\0'
|    |    |    |--在计算字符串长度不包括'\0'，计算字符串大小包括'\0'
|
|--结构体类型
|    |--性质：结构体是用来存放一组不同类型的数据的数据结构，其中变量称为结构体的成员
|    |--种类
|    |    |--结构体模板：struct structName{ type variable; type array[]; struct structname };
|    |    |--结构体变量：struct variable;
|    |    |--结构体数组：struct array[];
|    |    |--结构体指针：struct *p;
|    |--访问成员
|    |    |--variable.variable = value
|    |    |--array[i].variable = value
|    |    |--p->variable = value
|    |    |--(*p).variable = value
|    |--内存对齐
|    |    |--结构体在内存中是连续的，和数组类似
|    |    |--32位下CPU一次取值为4字节，64位下CPU一次取值为8字节
|    |    |--结构体的总大小为最宽成员大小的整数倍
|    |    |--根据CPU取值情况来判断是否需要补位，即一次或多次取一个成员，一次取多个成员
|    |    |--不可以出现一次取一个成员和另一个不完整的成员
|
|--枚举类型
|    |--性质：枚举是一种可定义同一事物的多种变量的数据类型
|    |--定义：enum typeName{valName1=value, valName2=value,...}varName;
|    |--特征
|    |    |--首值默认为0，依次向后递增
|    |    |--若其中某一变量赋值，则后续变量依次递增
|    |    |--枚举成员不可被赋值，只能将它们的值付给其他变量
|    |    |--在编译时枚举成员被转换为常量，它们不占数据区的内存，所以不能用&取值
|
|--共用体类型
|    |--性质：共用体是一种可存储多个数据类型的数据结构，所有成员共占用一段内存
|    |--特征
|    |    |--共用体占用的内存等于最长的成员占用的内存，共用体使用内存覆盖技术，同一时刻只能保存一个成员的值
|    |    |--当其中一个成员赋值时，其它成员处于未定义状态
|    |--定义：union unionName{ type variable; type array[]; union variable }variable, array
|
3. 指针类型
|--指针变量                        
|    |--指针本质                       32位编译器            64位编译器
|    |    |--指针：变量的类型地址           4                    8
|    |    |--指针变量：存储地址（指针），指向一个变量（代表一个变量）
|    |    |--定义指针变量带*  ： dataType *name;
|    |    |--赋值指针变量不带*： name = value_1;
|    |    |--取值指针变量带*  ：*name = value_2;
|    |    |--注意：只有形参传入实参的地址或引用时，才可以改变实参的值
|    |
|    |--指针运算
|    |    |--地址本质上是一个整数，所以可以进行加法、减法，比较
|    |    |--指针变量运算结果和指针类型有关，p+1加的是一个该指针类型单位
|    |
|    |--指针类型
|    |    |--空指针
|    |    |    |--值为NULL，不指向任何对象，对其操作可能会造成程序的锻错误
|    |    |    |--任何指针类型都可以指向空指针
|    |    |    |--对空指针进行操作会导致未定义的结果，可能运行结果错误，也可能导致程序崩溃
|    |    |--野指针：未初始化的指针，其缺省值是随机的，对其操作可能会造成非法访问
|    |    |--悬空指针：指针指向对象的内存已被销毁，但是指针的值（对象地址）仍存在
|
|--一维/二维数组指针 
|    |--定义数组、sizeof，&时数组名代表整个数组，其它表达式中数组名代表数组首元素地址
|    |    |--int p[3]    ==>  p代表整个数组
|    |    |--sizeof(p)   ==>  p代表整个数组，所以p的大小为(int)4x3=12
|    |    |--&(p)        ==>  p代表整个数组，因为p代表整个数组，所以&p+1则加4x3=12个字节
|    |    |--p           ==>  p代表数组中首元素地址，因为P指向1个int类型，所以p+1加4个字节
|    |--数组取下标操作符[i]相当于*(+i)
|    |    |--int p[3][2] ==>  *(p[3]+2) ==> *(*(p+3)+2)
|    |    |--p           ==>  p代表数组首元素地址，指向2个int类型数据
|    |    |--*p          ==>  *p获取数组首元素，即获取一组数组，则*p会退化成该数组首元素地址
|    |    |--**p         ==>  **p代表获取*p退化成数组首元素地址的值
|    |--切记数组名可以改写成指针，指针不可改写成数组
|
|--指针与函数
|    |--函数指针（指向函数的指针）：(*p)fun(int, int);
|    |--指针函数（函数的返回值为指针）：type *fun(int, int);|
|    |--特殊说明：函数名在表达式中会被转换为该函数所在区域的首地址
|
|--指针与结构体
|    |--使用变量访问成员：a.next
|    |--使用指针访问成员
|    |    |--p->next
|    |    |--(*p).next
|
4. 类型转换
|--自动类型转换
|    |--性质：编译器默默的，隐式的进行数据类型转换
|    |--触发条件
|    |    |--将一种类型的数据赋值给另外一种类型的变量时会发生自动类型转换
|    |    |--在不同类型的混合运算中，编译器会将参与运算的所有数据先转换为同一种类型再进行计算
|    |--转换优先级：short/char -->int -->unsigned -->long -->double <--float
|
|--强制类型转换
|    |--通过特定格式的代码来指明一种类型的转换
|    |--格式：（type_name）expression
|
|--特殊说明：两种类型的转换都是为了本次运算的临时转换
|
